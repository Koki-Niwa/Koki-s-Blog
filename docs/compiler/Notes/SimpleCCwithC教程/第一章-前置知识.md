---
sidebar_position : 2
---

## 前置知识
### CPU与内存

计算机的组成可以大致分为**CPU**和**内存**两部分。
内存是一种可以存储数据的设备，而CPU则是一种在读取和写入内存的同时执行各种处理的设备。

从概念上看，对CPU来说，内存就像一个**可以随机访问的巨大字节数组**。
当CPU访问内存时，它必须指定想访问的是第几个字节，这个数字被称为**地址（address）**。
例如，“从地址16读取8个字节的数据”表示“从这个看起来像字节数组的内存的第16个字节开始，读取8个字节的数据”。


CPU执行的程序和程序要读取或写入的数据，都存放在内存中。
CPU内部保存着一个数值，用来表示**当前正在执行的指令的地址**。
CPU会根据这个地址从内存中取出指令，执行它，然后取出下一条指令并执行。
这个“当前执行中的指令的地址”被称为**程序计数器（Program Counter, PC）**或**指令指针（Instruction Pointer, IP）**。
CPU所执行的程序本身的形式，就称为**机器语言（machine code）**。



### 分支与跳转

程序计数器并不总是简单地按顺序执行下一条指令。
CPU中有一种特殊的指令，叫做**分支指令（branch instruction）**，
它可以让CPU把程序计数器设置到**任意的地址**，而不仅仅是下一条指令。
正是利用这种机制，if语句和循环语句才能实现。
将程序计数器设置到非连续位置的行为，称为**跳转（jump）**或**分支（branch）**。



### 寄存器与内存访问

除了程序计数器外，CPU还拥有少量的数据存储空间。
例如，Intel和AMD的处理器中有**16个可以存放64位整数的寄存器（register）**。

内存(memory)对CPU来说属于外部设备，读写它需要一定时间；
而寄存器位于CPU内部，可以**几乎无延迟地**访问。

大多数机器指令的形式是：
“用两个寄存器中的值进行某种运算，然后把结果写回寄存器”。
因此，程序的执行过程本质上是：
CPU**从内存中把数据读入寄存器 → 在寄存器之间进行运算 → 把结果写回内存**，
如此循环往复。



### 指令集（Instruction Set）

某种机器语言中包含的所有指令统称为**指令集架构（Instruction Set Architecture, ISA）**，简称**指令集**。

指令集的设计并不是唯一的，每种CPU都可以自由设计自己的指令集。
不过，如果机器语言层面不兼容，就无法运行同一个程序，因此实际存在的指令集种类并不多。

在个人电脑（PC）上，主要使用Intel及其兼容厂商AMD的**x86-64**指令集。
x86-64是主流的指令集之一，但并不是唯一的。
例如，iPhone和Android设备中使用的则是**ARM**指令集。


### 专栏：x86-64指令集名称的由来

x86-64有时也被称为**AMD64**、**Intel 64**或**x64**。
同一种指令集却有这么多不同名字，是由历史原因造成的。

x86指令集最初由Intel于1978年开发。
而将其扩展为64位的是AMD。
在2000年前后，64位处理器的需求逐渐增长，但当时Intel正全力开发一款全新的指令集——**Itanium**，
因此他们并没有为x86制作64位版本。

趁此机会，AMD制定并公开了64位版x86的规范，这就是**x86-64**。
之后，AMD出于品牌考虑，将其更名为**AMD64**。

后来，Itanium项目的失败已成定局，Intel别无选择，只能开发自己的64位x86。
但当时AMD64芯片已在市场上普及，Intel如果重新制定一个不同但相似的标准，会带来兼容性问题。
在微软等厂商的压力下，Intel采用了与AMD几乎完全兼容的指令集，
并命名为**IA-32e（Intel Architecture 32 extensions）**。

这个名字中的“32”显示出Intel仍希望Itanium是“真正的64位CPU”的野心。
但后来Intel彻底放弃了Itanium，将IA-32e改名为**Intel 64**。
微软为了简化名称，将x86-64称为**x64**。

综上所述，x86-64之所以有这么多名字，完全是历史和商业策略共同作用的结果。

在开源社区中，人们通常更倾向于使用不含公司名称的**x86-64**这一称呼。
本教程也将统一采用**x86-64**这一名称。




---

## 汇编语言（Assembly）

机器语言是CPU直接读取并执行的指令形式，因此它的设计完全以CPU的需要为中心，**没有考虑人类的可读性**。
虽然理论上我们可以用十六进制编辑器直接编写机器语言程序，但那将是一项极其艰难、几乎无法忍受的工作。
为了解决这个问题，人们发明了**汇编语言（Assembly）**。

汇编语言是一种**几乎与机器语言一一对应的语言**，
但相比机器码，它**更易于人类阅读和编写**。

在生成**原生二进制文件（native binary）**的编译器中，
通常的目标是**输出汇编代码**。
虽然有些编译器看起来好像直接输出机器码，
但在很多实现中，它们实际上是先生成汇编文件，然后在后台调用汇编器（assembler）将其转换为机器码。
本教程将要制作的C编译器也会输出汇编代码。



### “汇编（assemble）”与“编译（compile）”

把汇编代码转换为机器语言的过程，有时也被称为“编译”，
但为了强调输入是汇编语言，
通常会特别称为“汇编（assemble）”。



### 查看汇编代码

你可能以前在某些地方见过汇编代码。
如果没有，现在正是一个很好的机会去看看。
我们可以使用 `objdump` 命令对任意可执行文件进行**反汇编（disassemble）**，
把其中的机器码转换为对应的汇编指令进行查看。

例如，下面是对 `ls` 命令进行反汇编的结果：

```bash
$ objdump -d -M intel /bin/ls
/bin/ls:     file format elf64-x86-64

Disassembly of section .init:

0000000000003d58 <_init@@Base>:
  3d58:  48 83 ec 08           sub    rsp,0x8
  3d5c:  48 8b 05 7d b9 21 00  mov    rax,QWORD PTR [rip+0x21b97d]
  3d63:  48 85 c0              test   rax,rax
  3d66:  74 02                 je     366a <_init@@Base+0x12>
  3d68:  ff d0                 call   rax
  3d6a:  48 83 c4 08           add    rsp,0x8
  3d6e:  c3                    ret
...
```

在作者的环境中，`ls` 命令包含大约 **两万条机器指令**，
因此反汇编的结果大约也有两万行。
上面只展示了最前面的几行。



### 汇编代码的结构

在汇编语言中，基本上是**一行对应一条机器指令**。
例如，来看这一行：

```
3d58:  48 83 ec 08           sub    rsp,0x8
```

这行代码是什么意思呢？

* `3d58`：这是该机器指令在内存中的**地址**。
  也就是说，当 `ls` 命令运行时，这条指令会被加载到内存地址 `0x3d58`。
  当程序计数器（PC）等于 `0x3d58` 时，这条指令将被CPU执行。

* `48 83 ec 08`：这四个十六进制数就是**实际的机器码**。
  CPU会从内存中读取这些字节，并把它们解释为一条具体的指令。

* `sub rsp,0x8`：这是这条机器码对应的**汇编表示**。
  根据CPU的指令集（后面章节会讲），
  这条指令的含义是：**从寄存器 RSP 的值中减去 8**（`sub` = subtract，减法）。



---

## C语言与对应的汇编代码

### 简单示例

为了理解 **C编译器会生成什么样的输出**，我们先来比较一段简单的 C 程序和它对应的汇编代码。

先看最简单的 C 程序：

```c
int main() {
  return 42;
}
```

假设我们把这段代码保存为 `test1.c`，可以通过以下命令编译并运行，来确认 `main` 函数确实返回了 42：

```bash
$ cc -o test1 test1.c
$ ./test1
$ echo $?
42
```

在 C 语言中，`main` 函数返回的值会作为**整个程序的退出码（exit code）**。
退出码不会直接显示在屏幕上，但会自动存储在 shell 的变量 `$?` 中。
所以我们可以在命令执行后用 `echo $?` 打印出来，查看该命令的退出码。
这里我们可以看到，程序确实返回了 `42`。



### 对应的汇编程序

上面这段 C 代码对应的汇编程序如下：

```asm
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

在这段汇编中：

* `.intel_syntax noprefix` 表示使用 Intel 风格的汇编语法；
* `.globl main` 表示 `main` 是一个**全局符号**（可以被程序的其他部分引用）；
* 标签 `main:` 后面是 `main` 函数的具体机器指令。

程序的执行过程是：
将常数 `42` 赋值给寄存器 `RAX`，然后通过 `ret` 指令从 `main` 返回。

x86-64 CPU 一共有 16 个可以存储整数的寄存器，其中之一是 `RAX`。
根据调用约定，**函数的返回值要放在 `RAX` 寄存器中**。
所以这里我们把 `42` 放进 `RAX`，就等于函数返回了 `42`。



### 实际汇编与执行

我们可以自己汇编并运行这段汇编程序。
汇编文件的扩展名通常是 `.s`，
所以将上面的代码保存为 `test2.s`，然后执行：

```bash
$ cc -o test2 test2.s
$ ./test2
$ echo $?
42
```

可以看到，与 C 代码的结果一样，程序返回了 42。



概括来说，**C 编译器** 就是这样一种程序：

> 它读取类似 `test1.c` 的 C 源代码，并生成类似 `test2.s` 的汇编代码作为输出。


### 含有函数调用的例子

接下来我们看一个稍微复杂一点的例子——**带有函数调用的 C 代码**。

在 C 中，函数调用不仅仅是“跳转（jump）”到另一个位置。
因为被调用的函数执行完后，还必须**返回到原来的位置**继续执行。
函数返回时要知道“从哪儿回”，这个地址叫做 **返回地址（return address）**。

如果程序中只有一次函数调用，返回地址可以放在某个寄存器里。
但函数调用可以**无限嵌套**（比如函数A调用B，B再调用C……），
因此返回地址必须存放在内存中。
实际上，返回地址被保存在内存中的一种结构里，叫做**栈（stack）**。

栈只需要一个变量来记录**栈顶的位置**就可以实现。
这个保存栈顶地址的寄存器叫做 **栈指针（stack pointer）**。
在 x86-64 架构中，有专门的寄存器（`RSP`）用于保存栈指针，
CPU 还提供了相应的指令来操作它。

* 向栈中压入数据叫做 **“push”**（入栈）；
* 从栈中取出数据叫做 **“pop”**（出栈）。

>数据结构-栈

>栈（Stack）是一种后进先出（Last In First Out，简称 LIFO）的线性数据结构。它类似于现实生活中的一摞盘子：你只能在最上面放一个新盘子（入栈），也只能从最上面拿走一个盘子（出栈）。

>用栈来保存函数的返回地址，可以保证嵌套函数的正确执行。

>读者可在[leetcode网站](https://leetcode.cn/ "leetcode")加深对这个数据结构的理解。


### 函数调用示例

让我们看下面这段 C 程序：

```c
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
```

对应的汇编代码如下：

```asm
.intel_syntax noprefix
.globl plus, main

plus:
        add rsi, rdi
        mov rax, rsi
        ret

main:
        mov rdi, 3
        mov rsi, 4
        call plus
        ret
```

第一行指定了汇编语法风格（Intel）。
第二行 `.globl plus, main` 表示 `plus` 和 `main` 这两个函数是**全局可见的**（外部可引用）。
暂时我们可以忽略这点。


### 分析 main 函数

在 C 代码中，`main` 调用了 `plus(3, 4)`。
在 x86-64 的调用约定中：

* **第一个参数** 放在寄存器 `RDI` 中；
* **第二个参数** 放在寄存器 `RSI` 中。

所以在汇编里，`main` 的前两行把 3 和 4 分别放进了 `RDI` 和 `RSI`。

接着出现的 `call plus` 指令，就是**函数调用指令**。
它会执行两件事：

1. 把“`call` 后面那条指令的地址”（即返回地址）压入栈中；
2. 跳转（jump）到被调用函数的地址（这里是 `plus`）。

因此，`call plus` 执行后，CPU 开始运行 `plus` 函数。


### 分析 plus 函数

`plus` 函数中有三条指令：

1. `add rsi, rdi`
   执行加法：把 `RSI + RDI` 的结果保存到 `RSI` 中。
   x86-64 的整数运算指令一般只接受两个操作数，
   所以结果会**覆盖第一个操作数**。

2. `mov rax, rsi`
   根据约定，**函数的返回值必须放在 `RAX` 寄存器中**。
   因此需要把结果从 `RSI` 复制到 `RAX`。
   注意：`mov`（move）指令其实并不“移动”数据，而是**复制（copy）**。

3. `ret`
   表示函数返回。它执行两件事：

   * 从栈中弹出（pop）一个地址；
   * 跳转到该地址继续执行。

   换句话说，`ret` 是与 `call` 成对使用的：
   `call` 把返回地址压栈，`ret` 把它弹出并跳回去。


### 函数返回值传递

当 `plus` 函数返回时，结果已经保存在 `RAX` 中。
`main` 函数中的下一条指令是 `ret`，
它会直接返回，而不会修改 `RAX`。

这样，`plus` 的返回值就顺利地成为了 `main` 的返回值。
最终程序返回 `7`（因为 `3 + 4 = 7`），
在 shell 中用 `echo $?` 也能看到这个退出码。

---

## C语言的main函数
在 C/C++ 等语言中，`main` 函数是程序的入口点，其参数用于接收命令行传递的参数。标准的 `main` 函数参数有两种形式：


### 1. 无参数形式
```c
int main() {
    // 程序逻辑
    return 0;
}
```
这种形式下，程序不接收命令行参数，直接执行内部逻辑。


### 2. 带参数形式（常用）
```c
int main(int argc, char *argv[]) {
    // 程序逻辑
    return 0;
}
```
两个参数的含义：
- **`argc`（argument count）**：  
  整数类型，表示命令行参数的**总个数**（包含程序名本身）。  
  例如，在命令行执行 `./program hello world` 时，`argc` 的值为 `3`（`./program`、`hello`、`world` 共 3 个参数）。

- **`argv`（argument vector）**：  
  字符串数组（或指针数组），存储具体的命令行参数。  
  - `argv[0]` 指向程序的**名称或路径**（如 `./program`）。  
  - `argv[1]` 指向第一个用户输入的参数（如 `hello`）。  
  - `argv[2]` 指向第二个用户输入的参数（如 `world`）。  
  - 以此类推，最后一个有效参数后是 `NULL`（作为结束标志）。


### 示例说明
假设编译后的程序名为 `test`，执行命令：
```bash
./test 123 "hello"
```
则 `main` 函数的参数为：
- `argc = 3`（参数个数：`./test`、`123`、`"hello"`）。
- `argv[0] = "./test"`（程序路径）。
- `argv[1] = "123"`（第一个参数）。
- `argv[2] = "hello"`（第二个参数）。
- `argv[3] = NULL`（结束标志）。


### 注意事项
- 参数传递的都是**字符串类型**，若需要数字，需手动转换（如用 `atoi` 转整数）。
- `argv` 也可写成 `char **argv`（本质上与 `char *argv[]` 等价，都是指向字符串的指针）。
- C++ 中还可使用 `int main(int argc, const char* argv[])`，`const` 表示参数不可修改。

通过这两个参数，程序可以灵活接收外部输入，实现更通用的功能（如命令行工具、文件处理等）。

---

## 操作系统（OS）简介
操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的系统软件，是计算机系统的核心与基石。它为用户和应用程序提供一个方便、高效、安全地使用计算机资源的接口，同时协调和控制计算机各个部件的运行。


### 操作系统的主要功能

1. **进程管理**  
   - 负责创建、调度、同步和终止进程。
   - 实现多任务处理（如并发、并行）。

2. **内存管理**  
   - 分配和回收内存空间。
   - 实现虚拟内存、内存保护和地址映射。

3. **文件系统管理**  
   - 管理文件的存储、检索、共享和保护。
   - 提供目录结构、文件权限等机制。

4. **设备管理（I/O 管理）**  
   - 控制和协调各种输入/输出设备（如键盘、鼠标、打印机、磁盘等）。
   - 通过设备驱动程序与硬件通信。

5. **用户接口**  
   - 提供命令行界面（CLI）或图形用户界面（GUI），让用户与系统交互。

6. **安全与保护**  
   - 控制用户访问权限，防止未授权操作。
   - 保护系统资源不被恶意程序破坏。

### 常见的操作系统

- **Windows**（微软）：广泛用于个人电脑，图形界面友好。
- **macOS**（苹果）：专用于 Mac 电脑，基于 UNIX，注重用户体验与安全性。
- **Linux**：开源、免费，广泛用于服务器、嵌入式系统和开发环境，类UNIX系统。常见发行版有 Ubuntu、CentOS、Debian 等。
- **UNIX**：多用户、多任务操作系统，是许多现代操作系统的鼻祖。
- **Android**：基于 Linux 内核，主要用于移动设备。
- **iOS**：苹果的移动操作系统，封闭但高度优化。

---

## 本章总结

在本章中，我们讲解了**计算机在内部是如何运作的**，以及**C编译器需要完成哪些工作**的整体概念。
虽然汇编语言或机器码乍看之下像是一堆杂乱的数据，与C语言相去甚远，但仔细观察后，你可能会发现它们其实在结构上相当忠实地反映了C语言的逻辑。

本书目前还没有详细解释机器码的具体内容，因此通过 `objdump` 查看汇编代码时，你可能还无法理解每条指令的确切含义。
但希望你已经体会到：**每一条机器指令其实只做非常小而简单的事情**。到本章为止，能够形成这样的直觉就已经足够了。



###  本章要点总结

* CPU通过**读写内存**来推进程序的执行。
* **程序的代码和数据**都存放在内存中，CPU从内存中**顺序读取机器指令并执行**。
* CPU拥有若干称为**寄存器（register）**的小型存储区域，大多数机器指令都是**在寄存器之间进行操作**的。
* **汇编语言**是机器码的**人类可读形式**，而C编译器通常会生成汇编代码。
* C语言中的函数在汇编中也会被编译成**函数形式**。
* **函数调用**是通过**栈**机制实现的。
* C语言main函数的含义
* 操作系统的基础知识  

### 专栏：在线编译器（Online Compiler）

观察C代码及其编译后的汇编输出，是学习汇编语言的非常有效的方法。
不过，每次都要修改源代码、重新编译、再查看输出，确实挺麻烦。
这时，有一个非常方便的在线工具可以帮助你——[Compiler Explorer（昵称 godbolt）](https://godbolt.org/)。

在Compiler Explorer网站上，你只需在**左侧文本框输入C代码**，右侧就会**实时显示对应的汇编输出**。
当你想快速查看一段C代码是如何被编译成汇编时，强烈推荐使用这个网站。



