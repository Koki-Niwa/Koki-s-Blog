---
sidebar_position : 3
---

# 第二章-制作计算器级别的语言

在本章中，我们将作为制作C编译器的**第一步**，实现一个能够处理四则运算及其他算术运算符的编译器，使其能够编译如下表达式：

```
30 + (4 - 2) * -5
```

乍一看这似乎是个简单的目标，但实际上并不容易。
因为数学表达式具有层级结构——比如括号内的式子优先计算、乘除优先于加减等。
要正确计算，就必须**理解这些隐藏的结构**。
而输入的表达式只是一个**平坦的字符串**，并没有结构信息。
因此我们需要解析这个字符串，从中**推导出表达式的树形结构**，才能正确地计算结果。

这种问题被称为**语法解析**（**Parsing**）问题。
如果完全没有相关知识而想自己去解决，会相当困难。
事实上，这类问题在上世纪50年代到70年代曾被认为是编译器研究的核心难题，学界当时开发了许多解析算法。
多亏了这些成果，如今只要理解方法，语法解析已经不再是高门槛的技术。

本章将介绍一种**最常见的解析算法——递归下降解析法（recursive descent parsing）**。
你每天使用的C/C++编译器（如GCC或Clang）也采用了这种方法。

语法解析并不仅限于编译器。
当我们需要读取有结构的文本（如配置文件、脚本语言、表达式求值器等）时，解析技术都能派上用场。
可以说，**掌握语法解析的技巧是一生受用的编程技能**。
本章的目标是理解该算法，并把它放入你作为程序员的“工具箱”中。

---

## Step 1：实现“编译单个整数”的语言

让我们思考一个“最简单的C语言子集”。
可能有人会想到“只包含main函数的语言”，或者“只由一个表达式组成的语言”。
但实际上，最极致的简化形式是——**语言中只能出现一个整数常量**。

我们就从这里开始：
编写一个**读入一个整数并输出对应汇编代码**的编译器。
输入类似：

```
42
```

输出汇编代码如下：

```asm
.intel_syntax noprefix
.globl main
main:
    mov rax, 42
    ret
```

`.intel_syntax noprefix` 是指定汇编格式为Intel风格的指令（不同于AT&T格式）。
以后我们所有汇编代码都将使用Intel语法。

你可能会想：“这种程序也能叫编译器吗？”
作者也承认——确实太简单了。
但严格来说，它**把一种语言（整数）翻译成另一种语言（汇编）**，完全符合编译器的定义。
而且从这个骨架出发，我们很快就能扩展出功能强大的C编译器。
所以，先完成这个“Hello, Compiler!”版本吧。


### 编译器主体代码

下面是最小实现的C程序：

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "参数数量错误\n");
    return 1;
  }

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %d\n", atoi(argv[1]));
  printf("  ret\n");
  return 0;
}
```

在空目录下创建 `9cc.c`，然后在终端输入（$号表示用户输入的开始，实际终端中不需要输入，下同）：

```bash
$ cc -o 9cc 9cc.c
$ ./9cc 123 > tmp.s
$ cat tmp.s
```

输出为：

```asm
.intel_syntax noprefix
.globl main
main:
  mov rax, 123
  ret
```

然后汇编并执行：

```bash
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
123
```

`$?` 是Shell中的上一个命令的退出码。
这里输出123，说明我们的“编译器”成功地把输入数字编译成汇编，并让程序返回该值。


### 自动化测试

为了验证编译器每次修改后的正确性，我们编写一个简易测试脚本 `test.sh`：

```bash
#!/bin/bash
assert() {
  expected="$1"
  input="$2"

  ./9cc "$input" > tmp.s
  cc -o tmp tmp.s
  ./tmp
  actual="$?"

  if [ "$actual" = "$expected" ]; then
    echo "$input => $actual"
  else
    echo "$input => $expected expected, but got $actual"
    exit 1
  fi
}

assert 0 0
assert 42 42

echo OK
```

给脚本执行权限并运行：

```bash
$ chmod a+x test.sh
$ ./test.sh
0 => 0
42 => 42
OK
```

如果结果不符，它会打印错误信息。

这个简单的脚本就是我们整本书中使用的“测试框架”。
虽然比不上JUnit等框架，但它**足够轻量、足够实用**。



### 用 make 自动化构建

接下来创建 `Makefile`：

```makefile
CFLAGS=-std=c11 -g -static

9cc: 9cc.c

test: 9cc
	./test.sh

clean:
	rm -f 9cc *.o *~ tmp*

.PHONY: test clean
```

现在可以直接运行：

```bash
$ make test
```

它会自动编译并运行测试。
`make clean` 则用于删除临时文件。

> 注意：Makefile 中的缩进必须是**Tab**，不能用空格。



### 使用 git 进行版本管理

创建 `.gitignore`：

```
*~
*.o
tmp*
a.out
9cc
```

初始化仓库：

```bash
$ git init
$ git add 9cc.c test.sh Makefile .gitignore
$ git commit -m "实现了可编译单个整数的编译器"
```

之后可以查看历史：

```bash
$ git log -p
```

最后，将仓库推送到 GitHub：

```bash
$ git remote add origin git@github.com:<你的用户名>/9cc.git
$ git push -u origin master
```


###  总结

到这里，我们完成了第一个“编译器”的实现。
它虽然只能处理一个整数，但具备了一个真正编译器的雏形：

* 输入源代码（整数）
* 解析输入
* 生成汇编代码
* 汇编后运行输出预期结果

接下来，我们将在这个基础上不断扩展功能，让它逐步成长为一个**完整的C编译器**。
现在，恭喜你完成了9cc的第一步！

---
## Step 2：实现支持加减运算的编译器

在这一步，我们将扩展前一章写的编译器，让它不仅能处理像 `42` 这样的单一整数，还能处理包含**加减运算**的表达式，例如：

```
2+11
5+20-4
```



####  编译器 vs 解释器


- **编译器**：将整个源代码一次性翻译成机器能直接识别的目标代码（如二进制文件），翻译完成后再运行目标代码。翻译一次可多次运行，执行速度快，但编译过程耗时，调试难度稍高。
- **解释器**：不生成独立目标文件，逐行读取源代码，翻译一行就执行一行，没有“提前完整翻译”的步骤。启动快、调试便捷（报错能精准定位到行），但每次运行都要重新翻译，执行效率较低。

应用场景：
- 编译器：适用于对执行速度要求高的场景，比如C、C++、Java（Java先编译为字节码，再由JVM解释执行，属于混合模式）。
- 解释器：适用于快速开发、脚本执行场景，比如Python、JavaScript、PHP。



像 `5+20-4` 这样的表达式，如果在编译阶段直接计算出结果（比如21）并把它写进汇编，那其实就成了解释器（interpreter），而不是编译器。

为了让**程序运行时**执行加减法，我们必须生成执行加减运算的汇编代码。
在汇编中，加法和减法由 `add` 和 `sub` 指令完成：

* `add`：对两个寄存器的值相加，并把结果写回第一个寄存器；
* `sub`：执行减法，规则相同。

例如，`5+20-4` 对应的汇编代码如下：

```asm
.intel_syntax noprefix
.globl main

main:
    mov rax, 5
    add rax, 20
    sub rax, 4
    ret
```

这段汇编做了以下事情：

1. 把 `5` 放进寄存器 `RAX`
2. 再加上 `20`
3. 再减去 `4`
4. 最后返回结果

当 `ret` 执行时，`RAX` 中的值就是 `5+20-4 = 21`。

我们可以验证：

```bash
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
21
```

结果显示 `21`，说明程序执行正确。


### 语言的定义

为了让编译器理解这种表达式，我们可以这样定义这种“小语言”：

1. 开头必须是一个数字；
2. 之后可以跟零个或多个“项”（term）；
3. 每个“项”要么是 `+数字`，要么是 `-数字`。

以后我们会用“文法”更严谨地定义“语言”


###  编译器的C代码实现

根据上面的规则，我们把语言定义直接写进C程序：

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "参数数量错误\n");
    return 1;
  }

  char *p = argv[1];

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %ld\n", strtol(p, &p, 10));

  while (*p) {
    if (*p == '+') {
      p++;
      printf("  add rax, %ld\n", strtol(p, &p, 10));
      continue;
    }

    if (*p == '-') {
      p++;
      printf("  sub rax, %ld\n", strtol(p, &p, 10));
      continue;
    }

    fprintf(stderr, "错误字符: '%c'\n", *p);
    return 1;
  }

  printf("  ret\n");
  return 0;
}
```



###  代码说明

这个程序比前一章稍长，但结构仍然很清晰：

* 前半部分（检查参数、打印 `.intel_syntax` 等）和 `ret` 行与之前完全一样。
* 新增部分是中间的循环，用来解析包含 `+` 和 `-` 的表达式。

这里使用了 `strtol` 函数而不是 `atoi`。
原因是：

* `atoi("123abc")` 只会返回 123；atoi意为ascii to integer ASCII字符到整数。
* 但我们还需要知道**读到了哪里**，以便处理后面的 `+` 或 `-`；
* `strtol` 的第二个参数是一个指针的地址，函数会自动把它更新为“最后读取的字符之后的位置”。strtol意为string to long ,字符串到长整数。

例如：

```
输入: "5+20-4"
第一次读取数字后 p 指向 '+'
```

于是我们可以循环处理剩下的部分，每次读取一个项，输出对应的汇编行。

如果看不懂，可以借助大语言模型逐行解释代码，详细了解atoi函数、strtol函数的用法并尝试自己使用这两个函数编写程序。



###  编译与运行

修改 `9cc.c` 之后，直接运行：

```bash
$ make
$ ./9cc '5+20-4'
```

输出：

```asm
.intel_syntax noprefix
.globl main
main:
  mov rax, 5
  add rax, 20
  sub rax, 4
  ret
```

说明加减运算的汇编输出正确。



###  添加测试

打开 `test.sh`，在末尾加上一行：

```bash
assert 21 "5+20-4"
```

然后执行：

```bash
$ ./test.sh
```

应当输出：

```
5+20-4 => 21
OK
```



###  保存更改到 Git

把新版本提交到 Git 仓库：

```bash
$ git add test.sh 9cc.c
$ git commit
```

编辑器打开后输入提交信息：

```
实现了加法与减法
```

保存并退出。
最后推送到 GitHub：

```bash
$ git push
```



---

## Step 3：引入词法分析器（Tokenizer）

在前一个步骤中我们写的编译器有一个缺点：
如果输入中包含空白字符（例如空格），程序就会报错。

例如，当我们输入带空格的字符串 `5 - 3` 时，程序在尝试读取 `+` 或 `-` 时遇到了空白字符，于是编译失败：

```bash
$ ./9cc '5 - 3' > tmp.s
意外的字符: ' '
```

解决这个问题的方法有几种。
最简单的一种是：在读取 `+` 或 `-` 之前先跳过空白字符。
这种做法没有什么问题，但在本节中，我们将用另一种方式来解决它——**在读取表达式之前，先把输入字符串切分成一个个“单词”**。

就像日语或英语一样，算术表达式或编程语言也可以看作是**由一个个“单词”组成的序列**。
例如：
`5+20-4` 可以被视为由五个单词组成：`5`、`+`、`20`、`-`、`4`。

这些“单词”在编译器的术语中叫做 **“token”（词法单元）**。
单词之间的空白字符只是起到分隔作用，本身并不是单词的一部分。
因此，在把字符串分割成 token 时，去掉空白字符是很自然的。
这个过程叫做 **“tokenize（词法分析）”**。

将字符串分解为 token 还有另一个好处：
在分解时我们可以**给每个 token 分类并加上类型信息**。
例如：

* `+` 和 `-` 显然是运算符；
* `123` 则表示一个数值。

在词法分析阶段就为每个 token 确定好类型，可以让后续的语法分析阶段逻辑更加简单。

对于目前仅支持加减运算的语法来说，token 类型只有三种：

1. `+` 或 `-` 这样的**符号**；
2. **整数**；
3. **输入结束标记**（方便实现，就像字符串以 `\0` 结尾一样）。

我们使用**链表**这种数据结构来存储token数据，从而处理任意长度的输入。这样的数据结构也方便我们遍历。

>数据结构-链表

>链表(LinkList)是一种常见的线性数据结构，它由一系列节点组成，每个节点包含两部分：数据域（存储数据）和指针域（存储下一个节点的地址）。与数组不同，链表中的节点在内存中不必连续存储，而是通过指针连接形成链式结构。

>读者可在[leetcode网站](https://leetcode.cn/ "leetcode")加深对这个数据结构的理解。

下面是引入了词法分析器（Tokenizer）后的改进版编译器代码（含详细中文注释）：

```c
#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token 的种类
typedef enum {
  TK_RESERVED, // 符号（例如 + 或 -）
  TK_NUM,      // 整数 token
  TK_EOF,      // 表示输入结束的 token
} TokenKind;

typedef struct Token Token;

// Token 结构体定义
struct Token {
  TokenKind kind; // token 的种类
  Token *next;    // 指向下一个 token
  int val;        // 当 kind == TK_NUM 时，存放数值
  char *str;      // 对应的原始字符串
};

// 当前正在处理的 token
Token *token;

// 错误报告函数（参数和 printf 相同）
void error(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// 如果下一个 token 是期望的符号，则前进一个 token 并返回真；否则返回假
bool consume(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    return false;
  token = token->next;
  return true;
}

// 如果下一个 token 是期望的符号，则前进一个 token；否则报错
void expect(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    error("不是'%c'", op);
  token = token->next;
}

// 如果下一个 token 是数字，则返回它的值并前进一个 token；否则报错
int expect_number() {
  if (token->kind != TK_NUM)
    error("不是数字");
  int val = token->val;
  token = token->next;
  return val;
}

// 判断是否到达输入末尾
bool at_eof() {
  return token->kind == TK_EOF;
}

// 创建新 token 并连接到当前 token 之后
Token *new_token(TokenKind kind, Token *cur, char *str) {
  Token *tok = calloc(1, sizeof(Token));
  tok->kind = kind;
  tok->str = str;
  cur->next = tok;
  return tok;
}

// 将输入字符串 p 进行词法分析并返回 token 链表
Token *tokenize(char *p) {
  Token head;
  head.next = NULL;
  Token *cur = &head;

  while (*p) {
    // 跳过空白字符
    if (isspace(*p)) {
      p++;
      continue;
    }

    if (*p == '+' || *p == '-') {
      cur = new_token(TK_RESERVED, cur, p++);
      continue;
    }

    if (isdigit(*p)) {
      cur = new_token(TK_NUM, cur, p);
      cur->val = strtol(p, &p, 10);
      continue;
    }

    error("无法进行词法分析");
  }

  new_token(TK_EOF, cur, p);
  return head.next;
}

int main(int argc, char **argv) {
  if (argc != 2) {
    error("参数数量不正确");
    return 1;
  }

  // 进行词法分析
  token = tokenize(argv[1]);

  // 输出汇编代码的前半部分
  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");

  // 表达式的第一个 token 必须是数字，因此先读取它并输出 mov 指令
  printf("  mov rax, %d\n", expect_number());

  // 不断消费形如 “+ 数字” 或 “- 数字” 的序列并输出对应汇编
  while (!at_eof()) {
    if (consume('+')) {
      printf("  add rax, %d\n", expect_number());
      continue;
    }

    expect('-');
    printf("  sub rax, %d\n", expect_number());
  }

  printf("  ret\n");
  return 0;
}
```

这份代码大约有 150 行，虽然不算特别短，但逻辑并不复杂，从头到尾读一遍就能理解。

### 程序设计技巧说明：

* **全局变量 `token`**
  我们用全局变量 `token` 来表示词法分析器输出的 token 链表。
  语法分析器（parser）通过遍历这个链表来读取输入。
  虽然使用全局变量看起来不是很“优雅”，但在这里这样做能让代码更直观，就像把 token 当作输入流一样读取，反而更清晰。

* **封装访问接口**
  直接操作 `token` 的代码被封装在函数 `consume()`、`expect()` 等中。
  这样可以避免其他部分直接修改全局状态，使逻辑更安全清晰。

* **链表构建技巧**
  在 `tokenize()` 中，我们创建了一个虚拟的头节点 `head`，并从它开始追加新节点。
  最后返回 `head.next`。
  这种技巧能让代码更简洁，不需要额外判断“第一个节点”的特殊情况。
  虚拟头节点所占的内存可以忽略不计。

* **使用 `calloc` 而不是 `malloc`**
  `calloc` 和 `malloc` 都能分配内存，但 `calloc` 会自动将分配的内存清零。
  这样我们就不必手动初始化结构体字段。

读者可在大语言模型的帮助下体会这样设计的好处。



改进版编译器现在已经能自动跳过空白字符了。
可以在测试脚本 `test.sh` 中添加一行测试：

```bash
assert 41 " 12 + 34 - 5 "
```

由于 Unix 进程的退出码（`exit code`）必须在 0~255 之间，
编写测试时请确保表达式的计算结果也在这个范围内。

最后，把测试文件添加到 Git 仓库中，就完成了本步骤。



### 小结

通过引入 tokenizer（词法分析器），编译器现在能够：

* 正确处理带空格的输入；
* 将字符串分割为带类型的 token；
* 让后续语法分析逻辑更简单、更稳健。



