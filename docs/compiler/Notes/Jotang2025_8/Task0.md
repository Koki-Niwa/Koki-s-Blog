---
title: Task0
sidebar_position: 2
---
## 什么是编译器？编译器的大致工作流程是怎样的？
### 编译器：
一种特殊的软件，将用高级编程语言编写的源代码翻译成机器语言或低级代码（如汇编语言）
### 大致工作流程：
编译器的工作流程大致可以分为三个阶段，前端、中端、后端
#### 前端
**输入**：源代码
**输出**：经过语义检查的AST或者是中间表示IR
通常前端有以下部分
*   **词法分析**：
    *   读取源代码，将其分割成Token。例如，关键字 (`if`, `while`)、标识符（变量名、函数名）、常量（数字、字符串）、运算符 (`+`, `-`, `*`)、分隔符 (`;`, `{`, `}`) 等。
    *   通常使用**词法分析器生成器**（如 Lex, Flex）根据正则表达式规则自动生成，也可以手工编写。

*   **语法分析**：
    *  将Token组织成语法结构，通常是AST。
    *  通常使用**语法分析器生成器**（如 Yacc, Bison）根据上下文无关文法自动生成。也可以手工编写。

*   **语义分析**：
    *   检查 AST 是否符合语言的**语义规则**。这包括：
        *   **类型检查**：确保运算符作用于兼容的类型（如不能将字符串和整数相加），函数调用时参数类型和数量匹配等。
        *   **作用域解析**：确定变量、函数等标识符在何处声明，以及它们在代码中的可见范围。
        *   **其他语义检查**：如检查变量是否在使用前已声明，函数是否有返回值等。
#### 中端

主要对IR进行与**机器无关**的优化，以提高最终生成代码的效率（速度、大小等）。

*   **IR**：
    *   是一种介于高级语言和机器语言之间的、相对低级但平台无关的表示形式。常见的 IR 有三地址码 、静态单赋值形式 (SSA) 等。
    

*   **可以进行的优化**：
    *   **常量折叠**：在编译时计算常量表达式的结果。
    *   **死代码消除**：移除永远不会被执行或对程序结果无影响的代码。
    *   **公共子表达式消除**：避免重复计算相同的表达式。
    *   **循环优化**：如循环不变代码外提、循环展开等。
    *   **内联展开**：将小函数的调用替换为函数体本身，减少函数调用开销。

#### 后端 

将优化后的 IR 转换为目标机器的**机器代码**或**汇编代码**。
 **将 IR 映射到目标机器的指令集。**
*   **关键步骤**：
    *   **指令选择**：为 IR 中的操作选择最合适的目标机器指令。
    *   **寄存器分配**：决定哪些变量或临时值应该存储在有限的 CPU 寄存器中，哪些需要溢出到内存。这是后端最复杂和关键的优化之一。
    *   **指令调度**：调整指令的执行顺序，以充分利用 CPU 的流水线、超标量等特性，减少停顿，提高指令级并行度。

*   **目标代码优化**：
    *   在生成目标代码后，还可以进行一些针对特定机器架构的优化，如利用特定的 CPU 指令、调整内存访问模式等。

## LLVM 编译器的架构是怎样的？
LLVM编译器的主要架构与上述类似

此外
   * 使用LLVM IR作为中间语言
     - LLVM IR有**三种等价表示形式**：
       - **内存中的数据结构**（编译器内部使用）
       - **人类可读的文本格式（.ll 文件）**
       - **二进制位码格式（.bc 文件）**
  - 采用“Pass Manager”机制管理优化 Pass。
  - Pass 可以是 `FunctionPass`, `ModulePass`, `LoopPass` 等。
  - 支持自定义 Pass，开发者可插入自己的优化逻辑。
  - 支持不同优化级别（如 `-O0`, `-O1`, `-O2`, `-O3`, `-Os`）。
  

## 编译器中端的主要任务是什么？
主要对IR进行与**机器无关**的优化，以提高最终生成代码的效率（速度、大小等）